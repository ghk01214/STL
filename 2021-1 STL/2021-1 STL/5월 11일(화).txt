━━━━━━━━━━━━━━━━━━━━
저장시간: 2021-05-11 오후 1:51:44 화요일
━━━━━━━━━━━━━━━━━━━━
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5월 11일 화요일 (11주 1일)
// 
// Sequence Container - vector, deque, list...
// Associative Container - set / map			{ key, value }
// Unordered Associative Container - unordered_map
// 
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#include <set>
#include <iterator>
#include "pch.h"		// iostream, algorithm
#include "save.h"		// string_view, filesystem, fstream
#include "String.h"		// random, string

// [문제] "main.cpp"의 단어를 읽어 길이 오름차순으로 정렬한 후 출력하라.
// set은 항상 정렬하는 자료구조이므로 여기로 String 클래스를 사용해서
// "main.cpp"의 단어를 읽어 저장하자.
// 문제점 : set은 기본 정렬 연산자로 <을 사용한다.
// set의 원소로 사용하려는 타입은 어떻게 정렬해야 하는지 set에 알려줘야 한다.

int main()
{
	std::ifstream in{ "main.cpp" };
	std::set<String> s{ std::istream_iterator<String>{in}, {} };

	for (const String& s : s)
	{
		std::cout << s << std::endl;
	}

	Save("main.cpp");
}

━━━━━━━━━━━━━━━━━━━━
저장시간: 2021-05-11 오후 1:51:57 화요일
━━━━━━━━━━━━━━━━━━━━
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5월 11일 화요일 (11주 1일)
// 
// Sequence Container - vector, deque, list...
// Associative Container - set / map			{ key, value }
// Unordered Associative Container - unordered_map
// 
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#include <set>
#include <iterator>
#include "pch.h"		// iostream, algorithm
#include "save.h"		// string_view, filesystem, fstream
#include "String.h"		// random, string

// [문제] "main.cpp"의 단어를 읽어 길이 오름차순으로 정렬한 후 출력하라.
// set은 항상 정렬하는 자료구조이므로 여기로 String 클래스를 사용해서
// "main.cpp"의 단어를 읽어 저장하자.
// 문제점 : set은 기본 정렬 연산자로 <을 사용한다.
// set의 원소로 사용하려는 타입은 어떻게 정렬해야 하는지 set에 알려줘야 한다.

int main()
{
	std::ifstream in{ "main.cpp" };
	std::multiset<String> s{ std::istream_iterator<String>{in}, {} };

	for (const String& s : s)
	{
		std::cout << s << std::endl;
	}

	Save("main.cpp");
}

━━━━━━━━━━━━━━━━━━━━
저장시간: 2021-05-11 오후 1:54:02 화요일
━━━━━━━━━━━━━━━━━━━━
//-----------------------------------------------------------------------------
// String.h - STL 내부 동작을 관찰하기 위해 만든 자원을 확보하는 클래스
//
// 2021. 3. 30									Programmed by wulong
//-----------------------------------------------------------------------------
#pragma once

#include <random>
#include <string>
#include "pch.h"

//#define 관찰			// 이 주석을 풀면 special member의 동작을 알 수 있다.

// 2021. 4. 20
// String이 외부에 제공하는 반복자
class String_iterator
{
public:
	String_iterator() = default;
	String_iterator(char* p) : p{ p } {}
public:
	String_iterator operator+(int n) const { return String_iterator{ p + n }; }
	String_iterator operator-(int n) const { return String_iterator{ p - n }; }
	int operator-(const String_iterator& right) const { return p - right.p; }
public:
	String_iterator& operator++() { ++p; return *this; }
	String_iterator& operator--() { --p; return *this; }
public:
	char& operator*() { return *p; }
	char& operator*() const{ return *p; }
public:
	bool operator==(const String_iterator& right) const { return p == right.p; }
	bool operator!=(const String_iterator& right) const { return p != right.p; }
public:
	bool operator<(const String_iterator& right) { return p < right.p; }
private:
	char* p{ nullptr };
};

// 2021. 4. 27
// 역방향 반복자 추가
class String_reverse_iterator
{
public:
	String_reverse_iterator(char* p) : p{ p } {}
public:
	String_reverse_iterator& operator++() { --p; return *this; }
public:
	bool operator!=(const String_reverse_iterator& right) const { return right.p != p; }
public:
	char& operator*() { return *(p - 1); }
private:
	char* p{ nullptr };
};

template<>
struct std::iterator_traits<String_iterator>
{
	using iterator_concept = std::contiguous_iterator_tag;
	using iterator_category = std::random_access_iterator_tag;
	using ptrdiff_type = std::ptrdiff_t;
	using pointer = char*;
	using reference = char&;
	using value_type = char;
};

class String
{
private:
	// 2021. 4. 20
	using iterator = String_iterator;
	using value_type = char;
	// 2021. 4. 27
	using reverse_iterator = String_reverse_iterator;
public:
	String();
	String(size_t n);
	String(const char* str);
	~String();
public:
	String(const String& other);							// 복사생성자
	String& operator=(const String& other);					// 복사할당연산자

	String(String&& other) noexcept;						// 이동생성자
	String& operator=(String&& other)noexcept;				// 이동할당연산자
public:
	// 2021. 4. 20
	iterator begin() { return iterator{ p }; }
	iterator end() { return iterator{ p + num }; }
public:
	// 2021 4. 27
	iterator cbegin() const { return iterator{ p }; }
	iterator cend() const { return iterator{ p + num }; }
public:
	// 2021. 4. 27
	reverse_iterator rbegin() { return reverse_iterator{ p + num }; }
	reverse_iterator rend() { return reverse_iterator{ p }; }
public:
	size_t size() const { return num; }

	// 확보한 자원을 std::string처럼 이용할 수 있게 하자
	std::string get() const;
	void set(const std::string& s);
public:
	bool operator==(const String& right);
	// 2021. 5. 11
	bool operator<(const String& right) const { return num < right.num; }
private:
	size_t num;												// 확보한 자원의 수
	char* p;												// 확보한 자원의 위치
private:
	friend std::ostream& operator<<(std::ostream& os, const String& s);
	// 2021. 5. 4
	friend std::istream& operator>>(std::istream& is, String& s);
};

━━━━━━━━━━━━━━━━━━━━
저장시간: 2021-05-11 오후 1:54:12 화요일
━━━━━━━━━━━━━━━━━━━━
//-----------------------------------------------------------------------------
// String.h - STL 내부 동작을 관찰하기 위해 만든 자원을 확보하는 클래스
//
// 2021. 3. 30									Programmed by wulong
//-----------------------------------------------------------------------------
#pragma once

#include <random>
#include <string>
#include "pch.h"

//#define 관찰			// 이 주석을 풀면 special member의 동작을 알 수 있다.

// 2021. 4. 20
// String이 외부에 제공하는 반복자
class String_iterator
{
public:
	String_iterator() = default;
	String_iterator(char* p) : p{ p } {}
public:
	String_iterator operator+(int n) const { return String_iterator{ p + n }; }
	String_iterator operator-(int n) const { return String_iterator{ p - n }; }
	int operator-(const String_iterator& right) const { return p - right.p; }
public:
	String_iterator& operator++() { ++p; return *this; }
	String_iterator& operator--() { --p; return *this; }
public:
	char& operator*() { return *p; }
	char& operator*() const{ return *p; }
public:
	bool operator==(const String_iterator& right) const { return p == right.p; }
	bool operator!=(const String_iterator& right) const { return p != right.p; }
public:
	bool operator<(const String_iterator& right) { return p < right.p; }
private:
	char* p{ nullptr };
};

// 2021. 4. 27
// 역방향 반복자 추가
class String_reverse_iterator
{
public:
	String_reverse_iterator(char* p) : p{ p } {}
public:
	String_reverse_iterator& operator++() { --p; return *this; }
public:
	bool operator!=(const String_reverse_iterator& right) const { return right.p != p; }
public:
	char& operator*() { return *(p - 1); }
private:
	char* p{ nullptr };
};

template<>
struct std::iterator_traits<String_iterator>
{
	using iterator_concept = std::contiguous_iterator_tag;
	using iterator_category = std::random_access_iterator_tag;
	using ptrdiff_type = std::ptrdiff_t;
	using pointer = char*;
	using reference = char&;
	using value_type = char;
};

class String
{
private:
	// 2021. 4. 20
	using iterator = String_iterator;
	using value_type = char;
	// 2021. 4. 27
	using reverse_iterator = String_reverse_iterator;
public:
	String();
	String(size_t n);
	String(const char* str);
	~String();
public:
	String(const String& other);							// 복사생성자
	String& operator=(const String& other);					// 복사할당연산자

	String(String&& other) noexcept;						// 이동생성자
	String& operator=(String&& other)noexcept;				// 이동할당연산자
public:
	// 2021. 4. 20
	iterator begin() { return iterator{ p }; }
	iterator end() { return iterator{ p + num }; }
public:
	// 2021 4. 27
	iterator cbegin() const { return iterator{ p }; }
	iterator cend() const { return iterator{ p + num }; }
public:
	// 2021. 4. 27
	reverse_iterator rbegin() { return reverse_iterator{ p + num }; }
	reverse_iterator rend() { return reverse_iterator{ p }; }
public:
	size_t size() const { return num; }

	// 확보한 자원을 std::string처럼 이용할 수 있게 하자
	std::string get() const;
	void set(const std::string& s);
public:
	bool operator==(const String& right);
	// 2021. 5. 11
bool operator<(const String& right) const { return std::string(p, p + num) < std::string(right.p, right.p + right.num); }
private:
	size_t num;												// 확보한 자원의 수
	char* p;												// 확보한 자원의 위치
private:
	friend std::ostream& operator<<(std::ostream& os, const String& s);
	// 2021. 5. 4
	friend std::istream& operator>>(std::istream& is, String& s);
};

━━━━━━━━━━━━━━━━━━━━
저장시간: 2021-05-11 오후 1:55:37 화요일
━━━━━━━━━━━━━━━━━━━━
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5월 11일 화요일 (11주 1일)
// 
// Sequence Container - vector, deque, list...
// Associative Container - set / map			{ key, value }
// Unordered Associative Container - unordered_map
// 
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#include <set>
#include <iterator>
#include "pch.h"		// iostream, algorithm
#include "save.h"		// string_view, filesystem, fstream
#include "String.h"		// random, string

// [문제] "main.cpp"의 단어를 읽어 사전식 오름차순으로 정렬한 후 출력하라.
// set은 항상 정렬하는 자료구조이므로 여기로 String 클래스를 사용해서
// "main.cpp"의 단어를 읽어 저장하자.
// 문제점 : set은 기본 정렬 연산자로 <을 사용한다.
// set의 원소로 사용하려는 타입은 어떻게 정렬해야 하는지 set에 알려줘야 한다.

int main()
{
	std::ifstream in{ "main.cpp" };
	std::set<String> s{ std::istream_iterator<String>{in}, {} };

	for (const String& s : s)
	{
		std::cout << s << std::endl;
	}

	Save("main.cpp");
}

━━━━━━━━━━━━━━━━━━━━
저장시간: 2021-05-11 오후 2:15:22 화요일
━━━━━━━━━━━━━━━━━━━━
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5월 11일 화요일 (11주 1일)
// 
// Sequence Container - vector, deque, list...
// Associative Container - set / map			{ key, value }
// Unordered Associative Container - unordered_map
// 
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#include <set>
#include <iterator>
#include "pch.h"		// iostream, algorithm
#include "save.h"		// string_view, filesystem, fstream
#include "String.h"		// random, string

// [문제] String은 기본 사전식(lexicographical) 비교를 한다.
// 길이 오름차순으로 정렬 방식을 변경할려한다.

class LESS
{
public:
	bool operator()(const String& left, const String& right) const
	{
		return left.size() < right.size();
	}
};

int main()
{
	std::set<String, LESS> s{ "abcdef", "xyz", "hijk" };

	for (const String& s : s)
	{
		std::cout << s << std::endl;
	}

	Save("main.cpp");
}

━━━━━━━━━━━━━━━━━━━━
저장시간: 2021-05-11 오후 2:42:37 화요일
━━━━━━━━━━━━━━━━━━━━
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5월 11일 화요일 (11주 1일)
// 
// Sequence Container - vector, deque, list...
// Associative Container - set / map			{ key, value }
// Unordered Associative Container - unordered_map
// 
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#include <set>
#include <iterator>
#include "pch.h"		// iostream, algorithm
#include "save.h"		// string_view, filesystem, fstream
#include "String.h"		// random, string

// [문제] String은 기본 사전식(lexicographical) 비교를 한다.
// 길이 오름차순으로 정렬 방식을 변경할려한다.

int main()
{
	std::set<String> s{ "abcdef", "xyz", "hijk" };
	s.emplace("12345");
	auto [p1, b1] = s.insert("xyzaaa");			// structured binding
	auto [p2, b2] = s.insert("xyz");

	std::cout << *p1 << ", " << std::boolalpha << b1 << std::endl;
	std::cout << *p2 << ", " << std::boolalpha << b2 << std::endl;

	for (const String& s : s)
	{
		std::cout << s << std::endl;
	}

	Save("main.cpp");
}

━━━━━━━━━━━━━━━━━━━━
저장시간: 2021-05-11 오후 2:45:38 화요일
━━━━━━━━━━━━━━━━━━━━
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5월 11일 화요일 (11주 1일)
// 
// Sequence Container - vector, deque, list...
// Associative Container - set / map			{ key, value }
// Unordered Associative Container - unordered_map
// 
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#include <set>
#include <iterator>
#include "pch.h"		// iostream, algorithm
#include "save.h"		// string_view, filesystem, fstream
#include "String.h"		// random, string

// [문제] String은 기본 사전식(lexicographical) 비교를 한다.
// 길이 오름차순으로 정렬 방식을 변경할려한다.

int main()
{
	std::set<String> s{ "abcdef", "xyz", "hijk" };
	s.emplace("12345");

	auto [p1, ignore] = s.insert("xyz");			// structured binding
	auto p2 = s.find("xyz");

	if (p1 == p2)
		std::cout << "같은 반복자" << std::endl;

	for (const String& s : s)
	{
		std::cout << s << std::endl;
	}

	Save("main.cpp");
}

━━━━━━━━━━━━━━━━━━━━
저장시간: 2021-05-11 오후 3:18:58 화요일
━━━━━━━━━━━━━━━━━━━━
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5월 11일 화요일 (11주 1일)
// 
// Sequence Container - vector, deque, list...
// Associative Container - set / map			{ key, value }
// Unordered Associative Container - unordered_map
// 
// map : pair<key, value>
//		연관배열로 사용한다. (통계처리에 유용)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#include <vector>
#include <map>			// key/value pair이고 key = const
#include "pch.h"		// iostream, algorithm
#include "save.h"		// string_view, filesystem, fstream
#include "String.h"		// random, string

// [문제] 그룹 이름을 입력하면 멤버를 알려주는 map을 만든다.
// 그룹 이름을 입력하면 멤버를 출력한다.
// (그룹 이름이 없으면 멤버를 입력 받아 등록할 수도 있다.)

int main()
{
	std::map<std::string, std::vector<std::string>> m;

	m.insert(std::pair<std::string, std::vector<std::string>>("aaa", { "1", "2", "3" }));
	m.insert(std::make_pair(std::string("펄 시스터즈"), std::vector<std::string>{ "배인순", "배인숙" }));
	m["게임"] = { "쿠키런", "철권7" };
	m["코요태"] = { "김종민", "빽가", "신지" };

	std::string groupName;

	while (true)
	{
		std::cout << "그룹 이름 입력 : ";
		std::cin >> groupName;

		auto p = m.find(groupName);
		int end = std::stoi(groupName);

		if (!end)
			break;

		if (p == m.end())
		{
			std::cout << groupName << "은 없는 그룹." << std::endl;
			
			continue;
		}

		std::cout << "그룹 " << p->first << "의 멤버 : ";

		for (const std::string& s : p->second)
		{
			std::cout << s << " ";
		}

		std::cout << std::endl << std::endl;
	}

	Save("main.cpp");
}

